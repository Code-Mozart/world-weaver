generator kysely {
  provider = "prisma-kysely"

  // Optionally provide a destination directory for the generated file
  // and a filename of your choice
  output   = "../src/lib/types"
  fileName = "database.ts"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ABSTRACT MODELS

// Non-SQL Data Document Storage
model Document {
  id        Int    @id @default(autoincrement())
  worldCuid String
  name      String @unique
  jsonData  String

  @@index(worldCuid)
}

// Abstract node marking a position in the world
model Node {
  id Int   @id @default(autoincrement())
  x  Float
  y  Float

  Polygons            NodesOnPolygons[] @relation("NodesOnPolygons")
  NextNodesInPolygons NodesOnPolygons[] @relation("NextNodesInPolygons")
  Paths               NodesOnPaths[]    @relation("NodesOnPaths")
  NextNodesInPaths    NodesOnPaths[]    @relation("NextNodesInPaths")
}

// Abstract path that defines a chain of nodes, e.g. used for rivers
model Path {
  id Int @id @default(autoincrement())

  Nodes        NodesOnPaths[]
  PreviousPath Path[]         @relation("PathLinks")
  NextPath     Path[]         @relation("PathLinks")

  riverId    Int?
  mountainId Int?

  River    River?    @relation(fields: [riverId], references: [id])
  Mountain Mountain? @relation(fields: [mountainId], references: [id])
}

// Abstract polygon used to define regions in the world
model Polygon {
  id    Int               @id @default(autoincrement())
  Nodes NodesOnPolygons[]

  Coastline Coastline?
}

// WORLD MODELS

// Any extra information for elements in the world
model ExtraInformation {
  id   Int    @id @default(autoincrement())
  data String
}

// A coastline marking the edge between ground types in the world
model Coastline {
  id        Int    @id @default(autoincrement())
  worldCuid String
  polygonId Int    @unique

  // 0 Water
  // 1 Land
  // 2 Lava
  // 3 Void
  //
  // see src/lib/types/ground-type.ts
  groundType Int

  // Information
  name String?

  Shape Polygon @relation(fields: [polygonId], references: [id])

  @@index(worldCuid)
}

// River Sections may only be connected at their ends
model River {
  id        Int    @id @default(autoincrement())
  worldCuid String
  Path      Path[]

  // Information
  name String?

  @@index(worldCuid)
}

model Mountain {
  id        Int    @id @default(autoincrement())
  worldCuid String
  Path      Path[]

  // Information
  name String?

  @@index(worldCuid)
}

// MANY-TO-MANY-MODELS

model NodesOnPolygons {
  nodeId     Int
  nextNodeId Int?
  polygonId  Int

  Node     Node    @relation("NodesOnPolygons", fields: [nodeId], references: [id])
  NextNode Node?   @relation("NextNodesInPolygons", fields: [nextNodeId], references: [id])
  Polygon  Polygon @relation(fields: [polygonId], references: [id])

  @@id([nodeId, polygonId])
}

model NodesOnPaths {
  nodeId     Int
  nextNodeId Int?
  pathId     Int

  Node     Node  @relation("NodesOnPaths", fields: [nodeId], references: [id])
  NextNode Node? @relation("NextNodesInPaths", fields: [nextNodeId], references: [id])
  Path     Path  @relation(fields: [pathId], references: [id])

  @@id([nodeId, pathId])
}
